# GLaDOS - Topineur Language Compiler

GLaDOS is a complete toolchain for **Topineur**, an innovative programming language that harmonizes functional purity, object-oriented modeling, ownership semantics, and explicit effect tracking.

## What is Topineur?

**Topineur** (Objet-Fonctionnel Contractuel) combines the best features of modern programming languages:

- **Functional purity** (from Haskell) — reasoning about code
- **Object-oriented modeling** (from Scala) — domain modeling
- **Ownership semantics** (from Rust) — memory safety
- **Effect tracking** (from Haskell/Koka) — explicit side effects

**Key innovations:**
1. Objects are immutable values by default
2. Methods are pure functions unless effects are declared
3. Mutation is safe through linear types (ownership)
4. Effects are explicit and tracked (`!{IO}`, `!{State}`, etc.)
5. Traits and typeclasses coexist harmoniously

## What you get

- A complete compiler pipeline: **parser → type checking → desugaring → bytecode**
- A stack-based VM with tail-call optimization, closures, and object support
- **Static type inference** with Hindley-Milner algorithm
- **Effect system** for tracking side effects
- **Linearity checker** for ownership semantics
- Ready-to-run examples in `examples/topineur/`
- Comprehensive documentation in `docs/topineur/`

## Quick tour

```bash
# Build the executable (uses stack under the hood)
make

# Run a Topineur file
./glados examples/topineur/hello_world.top

# Show the AST
./glados --ast examples/topineur/hello_world.top

# Peek at the generated bytecode
./glados --disasm examples/topineur/factorial_recursive.top

# Show type annotations
./glados --types examples/topineur/factorial_recursive.top

# Run the Haskell unit tests locally
stack test
```

## Example Topineur code

### Hello World
```topineur
def main(): !{IO} Unit =
  println("Hello, Topineur!")
```

### Factorial
```topineur
def factorial(n: Int): Int =
  if n <= 1 then 1
  else n * factorial(n - 1)

def main(): !{IO} Unit =
  println(show(factorial(5)))
```

### Objects and Methods
```topineur
object type Point {
  x: Float
  y: Float

  def distance(): Float =
    sqrt(x * x + y * y)
}

def main(): !{IO} Unit =
  let p = Point { x = 3.0, y = 4.0 }
  println("Distance: " ++ show(p.distance()))
```

## Learn the project

### Topineur Documentation
- `docs/topineur/README.rst` — Documentation index
- `docs/topineur/user_manual.rst` — Complete user guide
- `docs/topineur/grammar.rst` — Formal BNF grammar
- `docs/topineur/language_reference.rst` — Technical reference
- `docs/topineur/compilation.rst` — Compilation pipeline (12 phases)
- `docs/topineur/security_review.rst` — Security analysis
- `TOPINEUR_MIGRATION.md` — Migration guide from Lisp

### Implementation Documentation
- `docs/ARCHITECTURE.md` — How the compiler and VM are structured
- `docs/INSTRUCTIONS.md` — Bytecode and runtime reference
- `docs/DEVELOPMENT.md` — Build, test, and debugging workflows

## Repository layout

```
.
├── app/                 Main CLI wiring
├── docs/                Project documentation
│   └── topineur/       Topineur language docs
├── examples/            Sample programs
│   └── topineur/       Topineur examples (.top)
├── src/                 Compiler, runtime, and builtins
│   ├── TopineurLexer.hs
│   ├── TopineurParser.hs
│   ├── TypeChecker.hs
│   ├── EffectChecker.hs
│   ├── LinearityChecker.hs
│   ├── ObjectDesugar.hs
│   ├── Compiler.hs
│   ├── CodeGen.hs
│   └── VM.hs
├── test/                Haskell unit tests
├── vscode/topineur/     VSCode syntax extension
└── Makefile             Shortcuts around stack
```

Key sources worth opening:
- `src/Compiler.hs` — Orchestration of all compilation passes
- `src/TopineurParser.hs` — Parser with precedence climbing (625 lines)
- `src/TypeChecker.hs` — Hindley-Milner type inference (335 lines)
- `src/EffectChecker.hs` — Effect system verification (155 lines)
- `src/LinearityChecker.hs` — Ownership semantics (175 lines)
- `src/ObjectDesugar.hs` — Transform objects/traits to core IR
- `src/CodeGen.hs` — Lowers IR into bytecode instructions
- `src/VM.hs` — The execution loop with object support

## Current status

**✅ Phase 1-3 Complete** (AST, Lexer, Parser, Type System)

- [x] AST extended with Topineur types (Type, Effect, ObjectDef, TraitDef)
- [x] Lexer with 120+ token types
- [x] Parser with operator precedence (9 levels)
- [x] Type checker with Hindley-Milner inference
- [x] Effect checker for row-polymorphic effects
- [x] Linearity checker for ownership semantics
- [x] Object desugaring to core IR
- [x] Complete documentation (formal grammar, user manual, security review)
- [x] VSCode syntax highlighting

**🚧 In Progress:**
- Full integration testing with Topineur examples
- Complete standard library implementation

**⏳ Next Steps:**
- Extend VM with full object/trait support
- Optimize bytecode generation
- Add more builtin functions

## Features

### Type System
- **Hindley-Milner type inference** — types are inferred automatically
- **Parametric polymorphism** — generic functions and types
- **Linear types** — ownership semantics (`!lin T`)
- **Effect annotations** — explicit side effects (`!{IO}`, `!{State}`)

### Language Features
- **Objects** — immutable by default, with methods
- **Traits** — interface definitions with implementations
- **Pattern matching** — destructure values with `match`
- **Higher-order functions** — lambdas and closures
- **Infix operators** — arithmetic, comparison, logical
- **Let bindings** — local variable declarations
- **If-then-else** — conditional expressions

### Compiler Features
- **Static analysis** — catch errors at compile time
- **Tail-call optimization** — efficient recursion
- **Closure conversion** — first-class functions
- **Bytecode generation** — compact VM instructions

## License

This repository is released under the MIT licence (see `LICENSE`).

## Credits

Created for EPITECH B-FUN-500 (GLaDOS) project.

Part 1: Lisp interpreter/compiler ✅ 44/44
Part 2: Custom language (Topineur) 🚧 In progress
